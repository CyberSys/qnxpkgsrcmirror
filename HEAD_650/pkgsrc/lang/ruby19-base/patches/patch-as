$NetBSD: patch-as,v 1.3 2012/02/23 14:15:58 taca Exp $

* Handle 64bit size of time_t.

--- thread_pthread.c.orig	2012-02-13 15:29:27.000000000 +0000
+++ thread_pthread.c
@@ -17,6 +17,18 @@
 #include <sys/resource.h>
 #endif
 
+#ifdef __QNXNTO__
+#include <sys/neutrino.h>
+#include <sys/storage.h>
+#include <sys/mman.h>
+#endif
+
+#if SIZEOF_TIME_T == 8
+#define FMT_TIME_T	"lld"
+#else
+#define FMT_TIME_T	"ld"
+#endif
+
 static void native_mutex_lock(pthread_mutex_t *lock);
 static void native_mutex_unlock(pthread_mutex_t *lock);
 static int native_mutex_trylock(pthread_mutex_t *lock);
@@ -66,15 +78,31 @@ static void
 native_mutex_initialize(pthread_mutex_t *lock)
 {
     int r = pthread_mutex_init(lock, 0);
+#ifdef __QNXNTO__ /* sync objs inherited across fork */
+    if (r == EBUSY) {
+	    r = 0;
+    }
+#endif
+
     if (r != 0) {
 	rb_bug_errno("pthread_mutex_init", r);
     }
 }
 
+#if !defined(__QNXNTO__) || _NTO_VERSION > 650
 #define native_mutex_reinitialize_atfork(lock) (\
 	native_mutex_unlock(lock), \
 	native_mutex_initialize(lock), \
 	native_mutex_lock(lock))
+#else
+/*
+ * sync objs not inherited across fork on QNX <= 650
+ * and therefore can't unlock before re-init.
+ */
+#define native_mutex_reinitialize_atfork(lock) (\
+	native_mutex_initialize(lock), \
+	native_mutex_lock(lock))
+#endif
 
 static void
 native_mutex_destroy(pthread_mutex_t *lock)
@@ -226,6 +254,8 @@ native_thread_destroy(rb_thread_t *th)
 #define STACKADDR_AVAILABLE 1
 #elif defined HAVE_PTHREAD_GETTHRDS_NP
 #define STACKADDR_AVAILABLE 1
+#elif defined(__QNXNTO__)
+#define STACKADDR_AVAILABLE 1
 #endif
 
 #ifdef STACKADDR_AVAILABLE
@@ -283,6 +313,12 @@ get_stack(void **addr, size_t *size)
 				  &reg, &regsiz));
     *addr = thinfo.__pi_stackaddr;
     *size = thinfo.__pi_stacksize;
+#elif defined(__QNXNTO__)
+#ifndef ROUNDUP
+#define ROUNDUP(x, m)   (((x) + (m) - 1) & ~((m) - 1))
+#endif
+    *addr = __tls()->__stackaddr;
+    *size = ROUNDUP((uintptr_t)__tls(), __PAGESIZE) - (uintptr_t)(*addr);
 #endif
     return 0;
 #undef CHECK_ERR
@@ -645,7 +681,7 @@ native_sleep(rb_thread_t *th, struct tim
 	}
     }
 
-    thread_debug("native_sleep %ld\n", tv ? tv->tv_sec : -1);
+    thread_debug("native_sleep %" FMT_TIME_T "\n", tv ? tv->tv_sec : -1);
     GVL_UNLOCK_BEGIN();
     {
 	pthread_mutex_lock(&th->interrupt_lock);
@@ -667,8 +703,8 @@ native_sleep(rb_thread_t *th, struct tim
 	    }
 	    else {
 		int r;
-		thread_debug("native_sleep: pthread_cond_timedwait start (%ld, %ld)\n",
-			     (unsigned long)ts.tv_sec, ts.tv_nsec);
+		thread_debug("native_sleep: pthread_cond_timedwait start (%"
+			     FMT_TIME_T ", %ld)\n", ts.tv_sec, ts.tv_nsec);
 		r = pthread_cond_timedwait(&th->native_thread_data.sleep_cond,
 					   &th->interrupt_lock, &ts);
 		if (r && r != ETIMEDOUT) rb_bug_errno("pthread_cond_timedwait", r);
