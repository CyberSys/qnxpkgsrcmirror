$NetBSD: patch-as,v 1.1.1.1 2010/09/12 03:50:06 taca Exp $

Handle 64bit size of time_t.

--- thread_pthread.c.orig	2010-07-22 13:13:57.000000000 +0000
+++ thread_pthread.c
@@ -16,6 +16,16 @@
 #ifdef HAVE_SYS_RESOURCE_H
 #include <sys/resource.h>
 #endif
+#ifdef __QNXNTO__
+#include <sys/storage.h>
+#include <sys/mman.h>
+#endif
+
+#if SIZEOF_TIME_T == 8
+#define FMT_TIME_T	"lld"
+#else
+#define FMT_TIME_T	"ld"
+#endif
 
 static void native_mutex_lock(pthread_mutex_t *lock);
 static void native_mutex_unlock(pthread_mutex_t *lock);
@@ -66,6 +76,13 @@ static void
 native_mutex_initialize(pthread_mutex_t *lock)
 {
     int r = pthread_mutex_init(lock, 0);
+#ifdef __QNXNTO__ /* sync objs inherited across fork */
+    if (r == EBUSY) {
+	    pthread_mutex_unlock(lock);
+	    r = 0;
+    }
+#endif
+
     if (r != 0) {
 	rb_bug_errno("pthread_mutex_init", r);
     }
@@ -201,6 +218,8 @@ native_thread_destroy(rb_thread_t *th)
 #define STACKADDR_AVAILABLE 1
 #elif defined HAVE_PTHREAD_GETTHRDS_NP
 #define STACKADDR_AVAILABLE 1
+#elif defined(__QNXNTO__)
+#define STACKADDR_AVAILABLE 1
 #endif
 
 #ifdef STACKADDR_AVAILABLE
@@ -258,6 +277,12 @@ get_stack(void **addr, size_t *size)
 				  &reg, &regsiz));
     *addr = thinfo.__pi_stackaddr;
     *size = thinfo.__pi_stacksize;
+#elif defined(__QNXNTO__)
+#ifndef ROUNDUP
+#define ROUNDUP(x, m)   (((x) + (m) - 1) & ~((m) - 1))
+#endif
+    *addr = __tls()->__stackaddr;
+    *size = ROUNDUP((uintptr_t)__tls(), __PAGESIZE) - (uintptr_t)(*addr);
 #endif
     return 0;
 #undef CHECK_ERR
@@ -620,7 +645,7 @@ native_sleep(rb_thread_t *th, struct tim
 	}
     }
 
-    thread_debug("native_sleep %ld\n", tv ? tv->tv_sec : -1);
+    thread_debug("native_sleep %" FMT_TIME_T "\n", tv ? tv->tv_sec : -1);
     GVL_UNLOCK_BEGIN();
     {
 	pthread_mutex_lock(&th->interrupt_lock);
@@ -642,8 +667,8 @@ native_sleep(rb_thread_t *th, struct tim
 	    }
 	    else {
 		int r;
-		thread_debug("native_sleep: pthread_cond_timedwait start (%ld, %ld)\n",
-			     (unsigned long)ts.tv_sec, ts.tv_nsec);
+		thread_debug("native_sleep: pthread_cond_timedwait start (%"
+			     FMT_TIME_T ", %ld)\n", ts.tv_sec, ts.tv_nsec);
 		r = pthread_cond_timedwait(&th->native_thread_data.sleep_cond,
 					   &th->interrupt_lock, &ts);
 		if (r && r != ETIMEDOUT) rb_bug_errno("pthread_cond_timedwait", r);
